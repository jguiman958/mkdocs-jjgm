{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About","text":"<p>Este es el contenido del archivo about.md</p>"},{"location":"bitnamiprestashop/","title":"Instalaci\u00f3n de Prestashop a traves de docker con la imagen de bitnami.","text":""},{"location":"bitnamiprestashop/#creacion-de-los-respectivos-contenedores-para-la-instalacion-de-wordpress","title":"Creaci\u00f3n de los respectivos contenedores para la instalaci\u00f3n de wordpress.","text":""},{"location":"bitnamiprestashop/#que-es-docker","title":"\u00bfQu\u00e9 es docker?","text":"<p>Docker es una plataforma de c\u00f3digo abierto dise\u00f1ada para facilitar la creaci\u00f3n, implementaci\u00f3n y ejecuci\u00f3n de aplicaciones en contenedores. Un contenedor se puede definir como un entorno ligero, aislado y portable, que contiene todo lo necesario (c\u00f3digo fuente, dependencias, etc.) para ejecutar una aplicaci\u00f3n, un contenedor suele tener un \u00fanico procesos en ejecuci\u00f3n, aunque es posible tener varios. Una de las ventajas que aporta el uso de contenedores es que garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno.</p> <p>Comandos importantes de docker:</p> <pre><code>Trabajamos con un fichero llamado docker-compose.yml\n-Para cargar dicho fichero usamos el comando:\ndocker-compose up\n\n- Para ver el listado de las imagenes\ndocker images\n\n- Para borrar las imagenes:\ndocker rmi -f &lt;id_imagen&gt;\n\n- Para listar los volumenes \ndocker volume ls\n\n- Para borrar las volumenes:\ndocker-compose down -v\n\n- Para ver el listado de los contenedores incluso los que se encuentran en segundo plano:\ndocker ps -a\n\n- Para borrar los contenedores\ndocker rm -f &lt;docker id&gt;\n\n</code></pre>"},{"location":"bitnamiprestashop/#trabajamos-con-un-fichero-docker-composeyml","title":"Trabajamos con un fichero docker-compose.yml","text":"<p>Por tanto lo vamos a explicar por parte.</p>"},{"location":"bitnamiprestashop/#comenzamos-con-la-parte-de-prestashop","title":"Comenzamos con la parte de prestashop.","text":"<pre><code>version: '3.3'\n\nservices:\n prestashop:\n    image: bitnami/prestashop:1.7\n    environment: \n      - PRESTASHOP_FIRST_NAME=${PRESTASHOP_FIRST_NAME}\n      - PRESTASHOP_LAST_NAME=${PRESTASHOP_LAST_NAME}\n      - PRESTASHOP_PASSWORD=${PRESTASHOP_PASSWORD}\n      - PRESTASHOP_HOST=${DNS_DOMAIN_SECURE}\n      - PRESTASHOP_EMAIL=${PRESTASHOP_EMAIL}\n      - PRESTASHOP_COUNTRY=${PRESTASHOP_COUNTRY}\n      - PRESTASHOP_DATABASE_HOST=mysql\n      - PRESTASHOP_DATABASE_NAME=${PRESTASHOP_DATABASE_NAME}\n      - ALLOW_EMPTY_PASSWORD=yes\n      - PRESTASHOP_DATABASE_USER=${PRESTASHOP_DATABASE_USER}\n      - PRESTASHOP_DATABASE_PASSWORD=${PRESTASHOP_DATABASE_PASSWORD}\n      - PRESTASHOP_DATABASE_PREFIX=${PRESTASHOP_DATABASE_PREFIX}\n      - PRESTASHOP_ENABLE_SSL=1\n      - PRESTASHOP_ENABLE_HTTPS=yes\n    volumes: \n      - prestashop_data:/bitnami/prestashop\n    depends_on:\n      - mysql\n    restart: always\n    networks:\n      - frontend-network\n      - backend-network\n</code></pre> <p>Que tenemos aqu\u00ed... La versi\u00f3n, la cual usa la versi\u00f3n de docker-compose: <code>3</code></p> <p>Seguidamente comenzamos con el servicio de wordpress que contiene estas ips para la instalaci\u00f3n.</p> <p>Sacando la imagen de docker hub, usando la instalacion de prestashop de bitnami tenemos que trabajar con las etiquetas que nos ofrece esa ofrece esa imagen de wordpress, es necesario establecer la version en concreto con la que vamos a trabajar <code>1.7</code></p> <p>En environment visualizamos las variables que contiene informaci\u00f3n sobre la instalaci\u00f3n automatizada de wordpress. Estas variables, para se exactos:</p> <pre><code># Dominio.\nDNS_DOMAIN_SECURE=docker-host.local\n\n# Creaci\u00f3n de las variables.\nPRESTASHOP_FIRST_NAME=Bitnami\nPRESTASHOP_LAST_NAME=User\nPRESTASHOP_PASSWORD=bitnami1\nPRESTASHOP_EMAIL=prestashop@prestashop.com\nPRESTASHOP_COUNTRY=es\nPRESTASHOP_LANGUAGE=es\nPRESTASHOP_DATABASE_HOST=mysql\nPRESTASHOP_DATABASE_NAME=prestashop\nPRESTASHOP_DATABASE_USER=ps_user\nPRESTASHOP_DATABASE_PASSWORD=ps_passwd\nPRESTASHOP_DATABASE_PREFIX=ps_\n\n\nMYSQL_ROOT_PASSWORD=root\n</code></pre> <p>Necesarios para la automatizaci\u00f3n de la instalaci\u00f3n.</p> <p>Se emplea tambien un volumen con nombre, para mantener la persistencia de datos, y que no se borren cuando se pare el contenedor.</p> <p>Docker-compose, funciona con etiquetas, no hace falta poner ips este fichero ya crear\u00e1 las redes con la etiqueta frontend-network y backend-network, tambien hay que tener en cuenta que depende de que mysql este en funcionamiento.</p>"},{"location":"bitnamiprestashop/#comenzamos-la-parte-de-la-instalacion-de-mysql","title":"Comenzamos la parte de la instalaci\u00f3n de mysql.","text":"<p>Como estamos trabajando con etiquetas, trabajamos siempre con nombres, ports...., image...., environment..., en el apartado environment disponemos de una serie de nombres donde debe incluirse con informaci\u00f3n el cual docker al ejecutarse, establecer\u00e1 los parametros necesarios, traido a traves de unas variables, traidas desde nuestro fichero env</p> <pre><code>  mysql:\n    image: mysql:8.0\n    ports:\n      - 3306:3306\n    environment:\n      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n      - MYSQL_DATABASE=${PRESTASHOP_DATABASE_NAME}\n      - MYSQL_USER=${PRESTASHOP_DATABASE_USER}\n      - MYSQL_PASSWORD=${PRESTASHOP_DATABASE_PASSWORD}\n    volumes:\n      - mysql_data:/var/lib/mysql\n    restart: always\n    networks:\n      - backend-network\n    security_opt:\n      - seccomp:unconfined\n</code></pre> <p>Disponemos inclusive de un volumen el cual hace que el contenedor de mysql sea persistente, restart hace que se reinicia en caso de que el contenedor se tumbe, asignandole la red del backend.</p> <p>Estableciendo unconfined para que no presenten restricciones en el contenedor.</p> <p>Estas son las variables que usa:</p> <pre><code>PRESTASHOP_DATABASE_NAME=prestashop\nPRESTASHOP_DATABASE_USER=ps_user\nPRESTASHOP_DATABASE_PASSWORD=ps_passwd\n</code></pre> <p>Como podemos ver concuerda con las variables de la base de datos asignada a prestashop.</p>"},{"location":"bitnamiprestashop/#comenzamos-la-parte-de-instalacion-de-phpmyadmin","title":"Comenzamos la parte de instalaci\u00f3n de phpmyadmin.","text":"<pre><code>  phpmyadmin:\n    image: phpmyadmin:5.2.1\n    ports:\n      - 8080:80\n    environment: \n      - PMA_HOST=mysql\n    restart: always\n    networks:\n      - frontend-network\n      - backend-network\n</code></pre> <p>Aqu\u00ed instala phpmyadmin tomando como host mysql y asignando las dos redes, las necesita para poder acceder a la base de datos desde el frontend, como comprobamos no le asignamos persistencia.</p>"},{"location":"bitnamiprestashop/#comenzamos-la-parte-de-instalacion-de-https-en-wordpress-para-securizarlo","title":"Comenzamos la parte de instalaci\u00f3n de https en wordpress, para securizarlo.","text":"<pre><code>  https-portal:\n    image: steveltn/https-portal:1\n    ports:\n      - 80:80\n      - 443:443\n    restart: always\n    environment:\n      DOMAINS: '${DNS_DOMAIN_SECURE} -&gt; http://prestashop:8080'\n      STAGE: 'production' # Don't use production until staging works\n      # FORCE_RENEW: 'true'\n    networks:\n      - frontend-network\n</code></pre> <p>En este caso, necesita los 80 y 443, http y https, http para que se pueda comunica con las otras maquinas, y https para que muestra el contenido de forma segura, encriptando las peticiones, es necesario usar la variable:</p> <pre><code>DNS_DOMAIN_SECURE=docker-dominio.ddns.net\n</code></pre> <p>Para acceder desde local, STAGE establecerlo en staging.</p> <pre><code>  https-portal:\n    image: steveltn/https-portal:1\n    ports:\n      - 80:80\n      - 443:443\n    restart: always\n    environment:\n      DOMAINS: '${DNS_DOMAIN_SECURE} -&gt; http://prestashop:8080'\n      STAGE: 'production' # Don't use production until staging works\n      # FORCE_RENEW: 'true'\n    networks:\n      - frontend-network\n</code></pre> <p>Como podemos ver en bitnami tanto para prestashop como wordpress los puertos son 8080 es necesario tenerlos abiertos en la m\u00e1quina.</p>"},{"location":"bitnamiprestashop/#parte-de-los-volumenes-y-redes-creadas-durante-la-creacion-del-fichero-docker-composeyml","title":"Parte de los volumenes y redes creadas durante la creaci\u00f3n del fichero docker-compose.yml","text":"<pre><code>volumes: \n  mysql_data:\n  prestashop_data:\n  ssl_certs_data:\n\nnetworks:\n  frontend-network:\n  backend-network:\n</code></pre> <p>Es necesario crear, estas redes y volumenes al final para que se asigne de forma correcta a los docker.</p>"},{"location":"bitnamiprestashop/#comprobacion-de-que-funciona-el-fichero","title":"Comprobaci\u00f3n de que funciona el fichero.","text":"<p>Comprobacion de que al lanzar el comando <code>docker-compose up</code> funcione.</p> <p></p> <p>Podemos comprobar que se ha ejecutado la instruccion correctamente y ya est\u00e1 prestashop instalado.</p>"},{"location":"bitnamiprestashop/#comprobacion-de-que-muestra-el-contenido-via-cliente-web-de-forma-segura","title":"Comprobaci\u00f3n de que muestra el contenido via cliente web de forma segura.","text":"<p>Podemos comprobar que muestra el contenido de forma segura, encriptando las peticiones y respuestas entre cliente y servidor. El certificado es valido por una autoridad certificadora.</p>"},{"location":"bitnamiprestashop/#prueba-de-que-funciona-con-un-certificado-autofirmado","title":"Prueba de que funciona con un certificado autofirmado.","text":""},{"location":"instalacionterraform/","title":"Practica_11. Construcci\u00f3n de instancias de una arquitectura en 3 niveles.","text":""},{"location":"instalacionterraform/#que-necesitamos","title":"\u00bfQu\u00e9 necesitamos?","text":"<p>Anteriormente hemos realizado la creaci\u00f3n de instancias manualmente, ahora lo idoneo ser\u00eda generar un script que nos permita crear instancias automaticamente, pero claro, para ello primero tenemos que construir dicho script... Lo haremos con terraform, terraform nos ayuda a realizar instalaciones desatendidas en aws.</p> <p>Las instrucciones usadas en terraform son: <code>terraform init</code>,<code>terraform fmt</code>, <code>terraform validate</code>, <code>terraform plan</code> y <code>terraform apply</code>.</p> <p>Los cuales cada uno realiza lo siguiente:</p> <pre><code>Terraform init --&gt; Descargamos los plugins del proveedor, en este caso el de aws.\n\nTerraform fmt --&gt; Formatea el fichero de configuraci\u00f3n para que sea mas legible, tareas que realiza: ajusta la indentaci\u00f3n, ordena los argumentos de los bloques de configuraci\u00f3n.\n\nTerraform validate --&gt; Validamos que la sintaxis del comando es correcta.\n\nTerraform plan --&gt; Mostramos los cambios que se van a aplicar.\n\nTerraform apply --&gt; Y aplicamos los cambios.\n</code></pre> <p>Debe realizarse seg\u00fan el orden que has ido ley\u00e9ndolo, de arriba para abajo puedes saltarte el validate... no te lo recomiendo.</p>"},{"location":"instalacionterraform/#fichero-maintf","title":"Fichero main.tf","text":""},{"location":"instalacionterraform/#en-este-apartado-tenemos-que-crear-al-proveedor-en-este-caso-es-aws-donde-queremos-crear-las-instancias","title":"En este apartado tenemos que crear al proveedor en este caso es aws, donde queremos crear las instancias...","text":"<pre><code># Configuramos el proveedor de AWS\nprovider \"aws\" {\n  region     = \"us-east-1\"\n  access_key = \"clave_acceso\" &lt;--ESTO CAMBIA SIEMPRE TENLO EN CUENTA\n  secret_key = \"secret_token\" &lt;--ESTO CAMBIA SIEMPRE TENLO EN CUENTA\n  token      = \"clave_token_aws\" &lt;--ESTO CAMBIA SIEMPRE TENLO EN CUENTA\n}\n</code></pre> <p>Es necesario poner la regi\u00f3n, la clave de acceso, la clave secreta y un token de autenticaci\u00f3n.</p>"},{"location":"instalacionterraform/#ahora-vamos-con-los-grupos-de-seguridad-es-necesario-uno-para-cada-instancia","title":"Ahora vamos con los grupos de seguridad, es necesario uno para cada instancia.","text":"<pre><code># CREACI\u00d3N DE LOS GRUPOS DE SEGURIDAD.\n# Creamos un grupo de seguridad para el frontend\nresource \"aws_security_group\" \"sg_frontend_terraform_1\" {\n  name        = \"sg_frontend_terraform_1\"\n  description = \"Grupo de seguridad para la instancia de frontend1\"\n\n  # Reglas de entrada para permitir el tr\u00e1fico SSH, HTTP y HTTPS\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Reglas de salida para permitir todas las conexiones salientes\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre> <p>Podemos ver que para asignar una regla de entrada y salida viene definido, dependiendo de si queremos conexiones entrantes o salientes, ingress, para entrantes, el cual se declara los puertos con <code>from_port, to_port,protocol, cidr_blocks</code> y egress para salientes.</p> <pre><code>resource \"aws_security_group\" \"sg_frontend_terraform_2\" {\n  name        = \"sg_frontend_terraform_2\"\n  description = \"Grupo de seguridad para la instancia de frontend2\"\n\n  # Reglas de entrada para permitir el tr\u00e1fico SSH, HTTP y HTTPS\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Reglas de salida para permitir todas las conexiones salientes\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre> <p>Lo mismo para este, solo que tiene los mismos por ser el frontend al igual que el anterior...</p> <pre><code># Creamos un grupo de seguridad para el servidor nfs.\nresource \"aws_security_group\" \"sg_nfs_terraform\" {\n  name        = \"sg_nfs\"\n  description = \"Grupo de seguridad para la instancia de nfs_server\"\n\n  # Reglas de entrada para permitir el tr\u00e1fico SSH, nfs.\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 2049\n    to_port     = 2049\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Reglas de salida para permitir todas las conexiones salientes\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre> <p>Ya el servidor nfs requiere puertos distintos.. pero la sintaxis es la misma... Cabe destacar que la sintaxis correcta es:</p> <p><code>resource \"aws_security_group\" \"nombre_grupo_seguridad\" {name =\"\" description=\"\"}</code></p> <p>Con seguir los ejemplos se entiende, es como si lo hicieramos desde el interfaz del navegador de aws, pero con sintaxis.</p> <p>Estos son los grupos de seguridad para el balanceador, incluyendo el puerto 443 el cual muestra el contenido de los frontend de forma segura.</p> <pre><code># Creamos un grupo de seguridad para el balanceador de carga.\nresource \"aws_security_group\" \"sg_load_balancer_terraform\" {\n  name        = \"sg_load_balancer_terraform\"\n  description = \"Grupo de seguridad para la instancia de load_balancer\"\n\n  # Reglas de entrada para permitir el tr\u00e1fico SSH, HTTP y HTTPS\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Reglas de salida para permitir todas las conexiones salientes\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre> <p>Lo mismo para el grupo de seguridad de backend... en este al final inclu\u00ed que aceptase los ping (icmp).</p> <pre><code># Grupo de seguridad para el backend\nresource \"aws_security_group\" \"sg_backend_terraform\" {\n  name        = \"sg_backend_terraform\"\n  description = \"Grupo de seguridad para la instancia de backend\"\n\n  # Reglas de entrada para permitir el tr\u00e1fico SSH, 3306 e icmp.\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 3306\n    to_port     = 3306\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress { # Regla para ping--&gt; ICMP.\n    from_port   = -1\n    to_port     = -1\n    protocol    = \"icmp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Reglas de salida para permitir todas las conexiones salientes\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre>"},{"location":"instalacionterraform/#creacion-de-las-instancias","title":"Creaci\u00f3n de las instancias.","text":"<p>Aqu\u00ed vamos a crear las instancias.</p> <p>La estructura es muy simple, simplemente tenemos que elegir el ami de la instancia, los componentes hardware que va a tener (memoria ram, procesadores...), la clave que eso viene definido cuando creamos nuestra instancia, en mi caso es vockey, el grupo de seguridad, el cual se le debe de asignar a la instancia con la siguiente directiva: [security_groups = [aws_security_group.sg_frontend_terraform_1.name]] y finalmente la etiqueta tag, la cual da nombre a la instancia.</p> <pre><code># CREACION DE LAS INSTANCIAS.\n# Creamos una instancia EC2 para el frontend 1 y frontend 2.\nresource \"aws_instance\" \"frontend_1_terraform\" {\n  ami             = \"ami-0c7217cdde317cfec\"\n  instance_type   = \"t2.small\"\n  key_name        = \"vockey\"\n  security_groups = [aws_security_group.sg_frontend_terraform_1.name]\n  tags = {\n    Name = \"frontend_1_terraform\"\n  }\n}\n</code></pre> <p>Con las demas son exactamente igual solo que con peque\u00f1as variaciones, lo unico que se debe cambiar es la etiqueta y el nombre de la instancia.</p> <pre><code>resource \"aws_instance\" \"frontend_2_terraform\" {\n  ami             = \"ami-0c7217cdde317cfec\"\n  instance_type   = \"t2.small\"\n  key_name        = \"vockey\"\n  security_groups = [aws_security_group.sg_frontend_terraform_2.name]\n  tags = {\n    Name = \"frontend_2_terraform\"\n  }\n}\n</code></pre> <pre><code># Creamos una instancia EC2 para el servidor nfs.\nresource \"aws_instance\" \"nfs_server\" {\n  ami             = \"ami-0c7217cdde317cfec\"\n  instance_type   = \"t2.small\"\n  key_name        = \"vockey\"\n  security_groups = [aws_security_group.sg_nfs_terraform.name]\n  tags = {\n    Name = \"nfs_server\"\n  }\n}\n</code></pre> <pre><code># Creamos una instancia EC2 para el balanceador de carga.\nresource \"aws_instance\" \"load_balancer\" {\n  ami             = \"ami-0c7217cdde317cfec\"\n  instance_type   = \"t2.small\"\n  key_name        = \"vockey\"\n  security_groups = [aws_security_group.sg_load_balancer_terraform.name]\n  tags = {\n    Name = \"load_balancer\"\n  }\n}\n</code></pre> <pre><code># Creamos una instancia EC2 para el backend.\nresource \"aws_instance\" \"backend\" {\n  ami             = \"ami-0c7217cdde317cfec\"\n  instance_type   = \"t2.small\"\n  key_name        = \"vockey\"\n  security_groups = [aws_security_group.sg_backend_terraform.name]\n  tags = {\n    Name = \"backend\"\n  }\n}\n</code></pre> <p>Si queremos comprobar que funciona, solo tenemos que irnos al panel de las instancias creadas de aws y comprobar que se ha iniciado.</p>"},{"location":"instalacionterraform/#comprobaciones","title":"Comprobaciones.","text":"<p>En esta imagen vemos que me ha creado todas esas instancias a la vez, exluyendo la del nodo principal e instancia1 y instancia2.</p> <p></p> <p>Y aqu\u00ed lo tenemos, esto nos ense\u00f1a a ver una forma c\u00f3moda de crear instancias, de forma muy sencilla.</p>"},{"location":"men%C3%BAprincipal/","title":"Este sitio web est\u00e1 creado por Juan Jos\u00e9 Guirado Ma\u00f1as.","text":""},{"location":"men%C3%BAprincipal/#introduccion","title":"Introducci\u00f3n.","text":"<p>Aqu\u00ed podemos encontrar informaci\u00f3n sobre como crear una arquitectura de forma autom\u00e1tica en aws, empleando terraform, construyendo instancias de forma autom\u00e1tica sin necesidad de hacerlo a mano, tambi\u00e9n, se ha establecido un post el cual instala prestashop con bitnami.</p>"},{"location":"men%C3%BAprincipal/#que-se-pretende","title":"\u00bfQu\u00e9 se pretende?","text":"<p>Se busca automatizar una creaci\u00f3n de instancias y un proceso de instalaci\u00f3n de prestashop a traves de docker, empleando la imagen oficial de bitnami.</p>"},{"location":"men%C3%BAprincipal/#que-se-ha-hecho","title":"\u00bfQue se ha hecho?","text":"<p>Se ha automatizado, los dos procesos, desde la automatizaci\u00f3n de la creaci\u00f3n de las instancias de aws, y la creaci\u00f3n de los contenedores de bitnami/prestashop para la supuesta automatizaci\u00f3n de la creaci\u00f3n de bitnami.</p>"},{"location":"men%C3%BAprincipal/#que-se-ha-conseguido","title":"\u00bfQu\u00e9 se ha conseguido?","text":"<p>Se ha conseguido que la ejecuci\u00f3n de los scripts y creaci\u00f3n de docker funcionen eficientemente, adem\u00e1s de que prestashop dispone de un certificado firmado por una autoridad certificadora de confianza.</p> <p>La autoridad certificadora de confianza usada es no ip.</p> <p>En caso de que quieran crear un dominio de forma gratuita recomiendo visitar --&gt; Enlace a no-ip</p> <p>Otros enlaces interesantes.</p> <p>Documentaci\u00f3n de terraform para instalaci\u00f3n --&gt; Terraform </p> <p>Documentaci\u00f3n de no-ip --&gt; No-ip</p> <p>Documentaci\u00f3n de bitnami-prestashop --&gt; Instalaci\u00f3n de Prestashop con bitnami</p> <p>Documentaci\u00f3n de docker --&gt; Docker</p>"}]}